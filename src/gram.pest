// Link S-expression grammar
//
// Every expression is either an atom or an S-expression: (head elems...)
// The head determines the type:
//   λ          → lambda definition
//   ↻          → do-block (sequence, return last)
//   :          → assignment
//   op/cn/name → application (train + args)
//   literal    → list literal
//
// Comments: ; to end of line

prg       = _{ SOI ~ sexpr ~ EOI }

sexpr     =  { "(" ~ inner ~ ")" | atom }

inner     = _{ lambda | doblock | assign | apply | list_inner }

lambda    =  { "λ" ~ params ~ sexpr+ }
doblock   =  { "↻" ~ sexpr+ }
assign    =  { ":" ~ ident ~ sexpr }

// Application: head is a train (ops/combinators/names), "|" terminates the train, followed by 1+ args
apply     =  { train ~ "|" ~ sexpr+ }

// List literal: first element is a value (not an operator), all elements are sexprs
list_inner =  { sexpr ~ sexpr* }

// A train is a sequence of operators, combinators, monadic markers, and names
// They are greedily consumed left-to-right
train     =  { train_elem+ }
train_elem = _{ mop | cfn | op | cn | ident }
mop       =  { op ~ ":" }
cfn       =  { (op | ident) ~ cn }

op        =  {
    "+" | "-" | "×" | "÷"
  | "¯"   // max
  | "_"   // min
  | "="   // eq
  | "&"   // amp / filter
  | "!"   // range / mod
  | "ρ"   // shape / reshape
}

cn        =  {
    "/"    // fold
  | "\\"   // scanl
  | "ǁ"   // each
}

params    =  { "(" ~ ident* ~ ")" }

atom      = _{ float | int | string | ident }

ident     = @{ (LETTER | OTHER_SYMBOL) ~ (LETTER | OTHER_SYMBOL | ASCII_DIGIT | "_")* }
int       = @{ "-"? ~ ASCII_DIGIT+ }
float     = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* }
string    = @{ "\"" ~ ("\"\"" | (!("\"") ~ ANY))* ~ "\"" }

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT    = _{ ";" ~ (!NEWLINE ~ ANY)* }
